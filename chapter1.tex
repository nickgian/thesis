\chapter{Introduction}\label{ch:introduction}

\section{Motivation}\label{sec:motivation}

Computer hardware and software continuously grow in size and complexity and as a
result ensuring the absence of exploitable behaviors is becoming increasingly 
difficult. In the era when \nick{where?}computer systems are used extensively to
carry important information (e.g. credit card numbers, national security
documents), it has been widely accepted that security of these systems is a
priority. Researchers have identified a number of potential vulnerabilities
which arise from the violation of known but in-practice unenforceable safety
and security policies.
 
So far, computer security has been delegated mostly to software, while
the hardware is being almost completely controlled by the software.
High-level languages are becoming more widely used, due to features
such as strong type systems with type inference and automatic memory
management, making programming less error prone and reducing the
number of exploitable bugs. Furthermore, in order to strengthen the
security of computing systems a variety of low-level mitigation
techniques \cite{Cowan:1998:SAA:1267549.1267554,PaX,
  Erlingsson:2007:LSS:1793914.1793919}
\TODO{reference some? stack canaries, ASLR, $W \oplus X$}
\nick{done}
% http://prosecco.gforge.inria.fr/personal/hritcu/talks/05-control-hijacking-defenses.pdf
% Ãšlfar Erlingsson: Low-Level Software Security: Attacks and Defenses. FOSAD 2007: 92-134
have been proposed, however these are mostly ad-hoc solutions designed
to prevent specific known attacks, rather than enforcing a security
policy by preventing a well-defined class of attacks, thus making it
hard to reason about their effectiveness. In fact most of these
mitigation techniques can be circumvented by attackers
\cite{Szekeres2013}, which has lead to a continuous ``chase'' between
attackers and security researchers.

One common attack technique is to exploit some low-level vulnerability
such as a buffer overflow, in order to redirect the control flow to
attacker injected code. This attack can be stopped by a simple
protection scheme known as $W \oplus X$, which enforces that a memory
page is either executable or writable but not both.  Unfortunately,
clever attack techniques can bypass $W \oplus X$. In particular,
attackers have been using code-reuse attacks (e.g. return/jump -
oriented programming) that allows them to chain together existing
pieces of code to achieve malicious behavior without directly
introducing new code.  Abadi~\ETAL\cite{abadi2005} introduced a
property called Control Flow Integrity (CFI), which provides effective
protection against control-flow hijacking attacks.  CFI enforces that
any execution of a program will respect a statically computed control
flow graph (CFG).  \ch{missing references throughout}

The main contribution of this thesis is the formalization and
verification of a dynamic monitor for CFI, based on a generic
hardware-software security mechanism.
%
We provide a precise attacker model and prove in Coq that the monitor
enforces a variant of the CFI property proposed by
Abadi~\ETAL\cite{AbadiBEL09}.
%
To obtain this result we prove refinement between a concrete
machine running a monitor satisfying our Coq specification
and an abstract machine having CFI by construction.
%
We conclude the proof using a novel generic result stating that under
certain assumptions CFI is preserved by refinement.
\ch{Is there anything missing here?}

\section{Thesis Outline}\label{sec:outline}
\Cref{ch:policies} of this thesis briefly describes the motivation for
effective and efficient security policies, the desired properties a
robust security policy must satisfy and puts into context the
framework we utilize in order to formalize the Control-Flow Integrity policy
and reason about the effectiveness of the enforcement mechanism we used.

\Cref{ch:cfi} discusses the current state of
research on enforcing and formalizing Control-Flow Integrity and clarifies
the design choices of our approach regarding enforcement of \CFI.

\Cref{ch:verified_cfi} explains how we used the framework of \cref{ch:policies}
in order to formally reason about the security properties of the \CFI policy and
our approach to enforcing it. 

Chapter 5.. conclusions, future work? Appendix with code and/or step
relations etc.?

\section{What needs to be done}

\begin{enumerate}
\item Re-read and polish the whole thing
\item Optimize figure placement - once comments are removed and content is settled
\item mention types on tags and DATA tag on registers
\item More things on concrete preservation?
\item A summary on the conclusions?
\item Call-stack protection in future work
\item Have a look at latest related work
\item think about appendix if we need one
\item think about diagrams, do we want more (\EG stopping for concrete machine)
\item Unified numbering? Theorems,figures,table all having one counter. Last time
  I tried to do this I failed.
\item Take care of first parts (abstract, thanksgiving, keywords, outline, etc.)
\item Decide capitalization. Symbolic or symbolic machine, enforce it through out the document.
\end{enumerate}