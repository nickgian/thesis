\message{ !name(chapter3.tex)}
\message{ !name(chapter3.tex) !offset(-2) }
\chapter{Control-Flow Integrity}\label{ch:cfi}

Restricting the control-flow of a program in some way is a technique widely
spread among security researchers. For example non-executable data (NXD)
can be considered as a form of (very) coarse-grained \CFI where control-flow is
not allowed to reach any memory region that holds non-executable data. Other
mitigation techniques such as protecting return addresses on the stack enforce
a form of coarse-grained \CFI.

Moreover it is common that security properties are enforced dynamically by code
that is statically injected to the program (\EG Inlined Reference Monitors (IRM)
\cite{Erlingsson04} follow that approach), thus some form of \CFI is required in
order to ensure that these checks are not circumvented. 

\TODO{Think about title}
\section{Balancing between performance and security}\label{sec:security_cfi}

Abadi \ETAL first proposed a technique to enforce \CFI based on IRMs. 
In particular, they proposed to mark all valid targets of \emph{indirect} 
control transfers with a unique identifier and inject checks before all 
indirect jumps (including return instructions). However they assume that any 
two destinations are equivalent, in the sense that they share the same 
identifier, if the CFG contains edges from the same  set of sources, which may
significantly reduce the precision of the CFG. 
The authors also note that a 2-ID approach where one identifier is used for 
calls and another for returns could provide adequate security in many cases. 

The work of Abadi \ETAL sparked interest of researchers who tried to improve
some of the weaknesses of the initial implementation, usually by choosing 
between performance against precision and vice-versa.

Bletsch \ETAL \cite{Bletsch:2011:MCA:2076732.2076783} followed the work
of Abadi \ETAL, but changed their checking mechanism to perform the check
after the control flow transfer has occurred which, as the authors claim,
reduced the cache pressure and resulted in better performance. Precision remains
the same with the implementation of Abadi \ETAL.

Zhang \ETAL \cite{Zhang2013} proposed \emph{Compact Control Flow Integrity
and Randomization} (CCFIR), a new efficient way to enforce coarse-grained \CFI.
CCFIR collects all valid targets of indirect control-transfers and stores them
in a random order, in a protected section called ``Springboard section''. 
Indirect control-transfers are only allowed to addresses that are in the
Springboard. Their implementation uses a 3-ID approach where one identifier is
used for calls and the two other identifiers are for returns, separating them
between returns to sensitive and non-sensitive functions. Their implementation
also supports interaction between protected and un-protected modules, which
makes it an attractive solution to coarse-grained \CFI.

The above techniques are evaluated in \cite{outofcontrol_ieeesp2014} where
the authors demonstrate code-reuse attacks against binaries protected by
coarse-grained \CFI. These attacks illustrate the need for fine-grained
\CFI which however incurs a high runtime-overhead penalty making deployment
of such a mechanism unlikely.

\subsection{Standard assumptions for effective \CFI}\label{sec:cfi_assumptions}

Most -if not all- \CFI implementations also come with a set of assumptions under
which \CFI holds. Two standard assumptions for all mechanisms that attempt to
enforce \CFI are:
\begin{itemize}
\item \emph{NXD} is an abbreviation for Non-Executable Data, a security
mechanism that disallows execution of data. 
\item \emph{NWC} stands for Non-Writable Code. Changing the code of a
program would allow an attacker to circumvent dynamic checks.
\end{itemize}

Both assumptions are fairly standard for modern computers and are enforced
through hardware or software. In some cases \emph{NXD} can be lifted, but
additional security risks and complexity is not worth the minor advantages
offered by such an action.

Many implementations that attempt to do fine-grained \CFI also require that
identifiers used to mark nodes in the CFG are unique.

\section{Formal verification of Control-Flow Integrity}\label{sec:cfi_verif}

In \cite{AbadiBEL09} Abadi \ETAL extended their original paper, with
-among other things- a more detailed formal study of \CFI. Their formalization
regarded a much simpler machine than the x86 omitting all the complexity in
modern systems. The machine has a few instructions, a separate data memory and
instruction memory which by the operational semantics of the machine are 
non-executable and non-writable (enforcing \NXD and \NWC by construction), and a
small set of registers.
Moreover, their attacker model permits arbitrary changes to the data memory,
arbitrary changes to all the registers but a few distinguished ones that are
used during the dynamic checks and no changes to the instruction memory.
The authors proof that under some assumptions \CFI is preserved for every step
even in the presence of an attacker as powerful as the one described above. 
Their formal study served as a guideline for the implementation, but as it is 
done on paper their proofs cannot be machine checked. Furthermore, their 
formalization omits less interesting but important details such as instruction 
encoding and decoding which as shown in \cite{MorrisettTTTG12} are far from 
trivial for the x86.

Machine-checked formal verification efforts include \cite{ZhaoLSR11}, which is
a SFI formalization for the ARM architecture that also enforces \CFI.
Their formalization was developed using the HOL theorem prover and a program
logic framework they created. However their benchmarks report a 240\% runtime
overhead. The authors of \cite{CriswellDA14} claim partial proofs for a \CFI
enforcement mechanism focused on the kernel of an operating system. Their
runtime overhead can also reach 100\%.

\section{Control-Flow Integrity over PUMP}\label{sec:cfi_pump}

The PUMP hardware allows us to efficiently (as shown in \cite{pump_ccs2014})
enforce, an effective fine-grained \CFI policy. 


\message{ !name(chapter3.tex) !offset(-111) }
