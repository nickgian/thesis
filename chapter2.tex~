\chapter{Safety and Security Policies}\label{ch:policies}
Currently the hardware provides only a small number of security mechanisms (XXX: name some), 
leaving most of the work to the software. This requires that the software performs various 
sanity-checks during an execution and that it carefully maintains various safety and security invariants, 
resulting in high runtime performance overheads.  

Many potentially effective mitigation techniques are not deployed because of the performance overhead 
they incur.  Another requirement for deployment of a protection mechanism is the compatibility with 
existing executables and the degree of intervention required by a human. 
Usually even making slight changes to a code (e.g. binary rewriting) and redistributing has high cost 
and the protection mechanism is likely to see very low adoption. 

The lack of efficient and effective generic ways to enforce security policies, forces programmers to protect 
their own code, a task which is not trivial even for the small and simply programs. As a result most, 
if not all, software carries weaknesses which can be exploited by an attacker. 
So called ``safe'' languages, automate some of the checks required and eases the work of the programmer,
for example by implementing array bounds checking or by disallowing pointer-arithmetic. 
However these solutions only reduce the chance of introducing exploitable bugs in a program 
and do not enforce stricter, more effective policies such as Control Flow Integrity
or complete Memory Safety (spatial/temporal protection for heap and stack). 
In addition, we still need effective and efficient protection mechanisms for a 
plethora of software written in unsafe languages such as C.

\section{A Programmable Unit for Metadata Processing}\label{sec:pump}

The Programmable Unit for Metadata Processing (PUMP) architecture (TODO: reference HASP)
allows us to efficiently implement a wide range of security policies (TODO: reference CCS) by associating metadata to the 
data being processed  (e.g., this is an instruction, this is from the network, this is private),
propagating the metadata as instructions are executed and using a rules-based system to check
invariants on the metadata in parallel with the main computation. Abstractly, the tag propagation 
rules form a partial function from a set of input tags to a set of output tags
$$(opcode, tag_{pc},tag_{instr}, tag_{arg1}, tag_{arg2}, tag_{arg3}) \nrightarrow (tag_{pc'},tag_{result})$$
informally read as, ``if the next instruction to be executed is opcode, the current tag of the 
program counter is $pc_{tag}$, the current tag on the instruction location is $tag_{instr}$
and the tags on the operands of the instruction are $tag_{arg1}, tag_{arg2}$ and $tag_{arg3}$
then if execution of the instruction is allowed the tag on the program counter should be set
to $tag_{pc'}$ and any new data created by the instruction should be tagged $tag_{result}$''.

On the hardware level, the PUMP is an extension to a conventional RISC architecture.
Every word of data in the machine - whether in the memory or a register,
is extended with a word-sized metadata tag.
These tags are not interpreted by hardware, instead the interpretation of the tags is left to
the software, thus making it easy to implement new policies on the metadata. Since tags are
word-sized, they can be pointers to complex data-structures of tags, such as tuples of tags, 
allowing for complex policies to be expressed and multiple orthogonal policies to be enforced
in parallel.

The hardware undertakes the correct propagation of tags from operands to results according 
to the rules defined by the software. A hardware rule cache mapping sets of input tags to sets 
of output tags is used for common case efficiency. On each instruction dispatch, in parallel 
with the usual behavior of an instruction (e.g.execution of an addition in the ALU),  the hardware 
forms the set of input tags and a lookup is performed on the rule cache. If the lookup is successful
a set of output tags is returned and combined with the results of the normal execution of the 
instruction a new state is produced. On the other hand, if the lookup failed, the hardware invokes a 
trusted piece of system software - the fault handler - which checks the input tags and decides 
whether there execution should be allowed or not. In the first case, the fault handler returns a set 
of result tags, a pair of set of input and output tags is formed and
inserted into the rules cache, while the faulting instruction is restarted and will now hit the cache.
Otherwise, execution of this instruction violated some rules of the enforced policy and execution should
not continue normally (e.g. should be halted).

As described in the original PUMP paper by Dehon et al (TODO: refer hasp paper) and in more detail 
in the follow-up (TODO: refer CCS paper) a rich set of effective security policies can be 
efficiently implemented using the architecture mentioned above. In particular, implementations of
dynamic typing, memory safety for heap-based data, control flow integrity and taint tracking
are described, evaluated against a specific threat model and benchmarked. The benchmarks
are done using a simulation of the described hardware and the two papers claim low
overhead (~10\% on average) for each of the policies named above.

Compared to other software solutions for enforcing security policies, the PUMP offers 
significantly lower overhead, thanks to dedicated hardware assistance, while the
fact that interpretation of the metadata is done by software offers flexibility
with regard to the policies that can be implemented, compared to hardware
implementing a specific policy.

While the PUMP offers flexibility at a low runtime performance overhead, there are more
overheads associated to such a mechanism. For example adding metadata to
all the data in the machine, would result in a 100\% memory overhead. In addition,
the extra hardware and the rule cache along with potentially larger memories could
result into a 400\% overhead on energy usage. (TODO: reference CCS paper)
The authors claim that a careful and well-optimized implementation can reduce these 
numbers, resulting in a 50\% energy overhead.

\section{Micro-policies: A Framework for Verified, Hardware-Assisted Security Monitors}\label{sec:micropolicies}


The software components that can be changed to enforce a security policy
are collectively called a micro-policy.
Unsurprisingly, designing a security policy, reasoning about it's effectiveness against potential
attackers and encoding it as a micro-policy can become a complex task. 
Azevedo et al (TODO: reference POPL paper) built a generic framework for defining micro-policies
on top of a simple machine modeling a RISC processor augmented with the PUMP hardware 
(referred to as concrete machine),  formalized this framework in Coq and used it to define 
and formally verify micro-policies for dynamic sealing, control-flow integrity, memory safety, 
compartmentalization and protecting the monitor code itself.
(XXX: maybe I should mention the word monitor at some point earlier)

The framework offers a high-level machine, called the symbolic machine, that abstracts away
from unnecessary implementation details and can be used as an interface to the concrete
machine, simplifying the work of the micro-policy designer. Additionally the symbolic machine is
used to simplify correctness proofs. To instantiate the symbolic machine, the micro-policy designer
needs to provide a set of symbolic tags which will be used to tag the various values of the machine,
a transfer function that monitors program execution and determines how tags are propagated in
each step and optionally a set of monitor services that are partial functions from machine states to
machine states and can be used to control the monitor's behavior dynamically.

In order to implement the micro-policy at the concrete machine level, one needs to additionally provide
machine code that implements the transfer function, an encoding of tags to words and machine code for
any monitor services that the micro-policy may use.
The relation between the symbolic and the concrete machine is formally defined as a two-way refinement
(forward and backward). This is a generic refinement proof, parameterized by the encoding of the
symbolic tags to words and a proof of correctness of the monitor code for a micro-policy.
The designer of a micro-policy can use this two-way refinement simply by providing these two
parameters.

\subsection{Correctness of micro-policies}\label{sec:basic}

For each micro-policy an abstract machine which serves as a specification to the invariants
the policy designer wants to enforce is defined. The abstract machine is ``correct'' by
construction, meaning that it's designed to respect those invariants. Using the symbolic
machine as an intermediate step to simplify the proofs, by proving a refinement between
the symbolic and the abstract machine and by utilizing the the generic refinement between
the symbolic and the concrete machine, we can prove a refinement between the abstract and 
the concrete machine, thus showing that every valid step for the concrete machine is also
a valid step for the abstract machine (XXX: say smth about steps and refinement earlier..)

(XXX: Basic machine, how much should I spend?)

\subsection{Basic Machine}\label{sec:basic}

All the machines introduced in the original paper by Azevedo et al (TODO: fix ref), 
as well as this thesis, have a similar structure. In particular, they share a common
RISC-based instruction set (with a few - uninteresting for the scope of this
thesis - exceptions) and they have a fixed number of general-purpose registers,
along with a pc register. Of course the abstract machine defined by the policy designer
can differ in various ways, but more similarities with the symbolic machine implies
easier proofs of correctness.

(XXX: write down a few rules?)

\subsection{Symbolic Machine}\label{sec:symbolic}

As mentioned above, the symbolic machine enables us to abstract away from various
low-level details of the concrete machine. We can express and reason about policies
in terms of mathematical objects written in Gallina rather than machine code and
the corresponding proofs for the concrete machine comes for free under some assumptions.
The symbolic machine follows the structure of the basic machine but it's augmented to 
better match a PUMP architecture. Specifically the symbolic machine is parameterized by the
following:
\begin{itemize}
\item A set of symbolic tags, used to tag the contents of the memory, the registers and the pc.
\item A partial function \textit{transfer}, that on every step checks whether the
step is allowed according to opcode of the instruction executed and the tags on it.
In the case it's allowed it returns a tag for the new pc and for any resulting data
from executing the instruction.
\item A partial function \textit{get\_service}, mapping addresses \textit{symbolic monitor
services}. In the symbolic machine, monitor services are represented as a tuple of
a partial function on machine states and a symbolic tag of the form \textit{ENTRY user\_tag}.
\item An internal machine state with an initial value, that can be used by monitor services.
\end{itemize}

The states of the symbolic machine consists of a memory, registers, a pc register and an internal state.
The memory  and register contents, as well as the pc, are all tagged with a symbolic tag
\textit{t}. We name their contents \textit{symbolic atoms} referred to with the notation
\emph{w@t}, where \emph{w} is the value (word) and \emph{t} is the tag.

At each step, a record named \textit{mvector} is formed. It consists of the current opcode,
the tag on the pc, the tag on the current instruction and optionally up to three tags
depending on the opcode of the instruction. The \textit{mvector} is passed to the transfer function
which decides whether the step violated the policy enforced by the transfer function and in this case
halts the machine, or if no violation occurred returns a tag for the new pc and a tag for any
results the instruction execution produced.

(TODO: example rules, full rules in apendix?)

\subsection{Concrete Machine}\label{sec:concrete}

The concrete machine is a model of the basic machine with PUMP hardware, in particular a \textit{rule
cache} and a software \textit{miss handler}. The instruction set has been extended with four
additional instructions that are meant to be used by monitor code only, a restriction enforced by the monitor 
self-protection mechanism.

The states of the concrete machine consists of a memory, registers, a pc register, an \textit{epc} register - 
a special purpose register that holds the address of the faulting instruction after a cache miss and a cache.
The cache works as a key-value store where a key is an \textit{input vector} that contains an instruction 
opcode, the concrete tag of the current instruction, the concrete tag of the pc and up to three operand tags, 
and a value is an \textit{output vector} which contain a tag for the new pc and a tag for any results from 
the execution of the instruction. Intuitively a concrete tag is the encoding into a word of a symbolic tag. 
Lifting this encoding relation to vectors, we get that a concrete vector is the encoding of a symbolic vector (\textit{mvector}). 
In accordance (XXX: em this sucks? does this word even exist? think about smth else?) to the symbolic machine
the contents of the memory, the registers, the pc and the epc are concrete atoms \textit{w@t} where w is
a word and t is the encoding of a tag into a word.

The stepping relation for the concrete machine is a bit more complicated than the one for the symbolic machine.
In particular, on each step the machine forms the \textit{input vector} and looks it up in the cache.
If the lookup succeeds then the instruction is allowed, a \textit{output vector} is returned by the cache
and the next state is tagged according to it. 
If the lookup fails, then the \textit{input vector} is saved in memory, the current pc is stored in epc and
the machine traps to the \textit{miss handler}.
The above are demonstrated in the two example rules below:

(TODO: put example rules)

Addresses 0 to 5 are used to store the \textit{input vector} and 6 to 7 are used by the miss handler
to store the \textit{output vector}. As a side-note, cache eviction is not modeled (an infinite cache is assumed).

\subsection{Concrete Policy Monitor}\label{sec:concrete_policy}

Unlike the symbolic machine, where the user cannot cannot change the \textit{transfer} function, 
enforcing a micro-policy on the concrete machine requires that we are able to protect the memory of
the policy monitor and that privileged instructions are not executed by user code.  
This self-protection policy can be easily composed with another micro-policy and enforced by the 
infrastructure described above. 

Using tags of the form, \USER{\ii{st}}, \ENTRY{\ii{st}}, \MONITOR we can distinguish between
user memory, monitor memory and monitor services. In particular \USER{\ii{st}} is used to tag
a user-level atom, where \ii{st} is the word-encoding of a symbolic tag. \MONITOR is used to tag
the monitor memory and a few reserved registers. The \pc is tagged with \MONITOR when
a monitor execution takes place and \USER{\ii{st}} when user-code is executed. The tag
\ENTRY{\ii{st}} is used to tag the first instruction of a monitor service and serves as an indication
that execution will continue under the privileged \MONITOR mode.

One important thing to note is that the miss handler for the concrete machine can take an arbitrary 
number of steps before deciding that no violation occurred and returning to \USERname mode, 
unlike the symbolic \TRANSFER function that do not

\section{Core Erlang}\label{sec:core_erlang}

As we mentioned before, Core Erlang is an intermediate representation of
Erlang, which is used by the compiler as a middle-ware tier between the textual
representation of the source code and the low level bytecode. It has clear and
simple semantics that allow for a straight forward translation from Erlang code
to Core Erlang code and from Core Erlang code to bytecode. It has a
simple grammar thus simplifying the process of pretty printing Core Erlang
programs for humans to read and edit. Its main goal is to facilitate the
development of tools that operate on the Erlang source code, such as profilers,
debuggers, source code optimizers and various programs that perform source code
instrumentations.

The current implementation of the Erlang compiler allows the programmer to
transform his program to the equivalent Core Erlang program and store its
textual representation. He can then read it to inspect or modify the code
transformation or even write some extra Core Erlang code by hand. However,
should he want to execute his code, he must compile it to BEAM bytecode and
then execute it as usual. There is no implementation of a Core Erlang
interpreter, even for debugging purposes, as there is for the Abstract Format
of the Erlang parse trees stored in the debugging information of a module. This
feature was necessary for our implementation, thus a major part of the
development cycle of our tool was dedicated to the creation of a reliable Core
Erlang interpreter.

In the rest of this section, we will provide a brief description of the Core
Erlang Abstract Syntax Tree as it is used in the Erlang compiler and its
semantics.

\subsection{The Core Erlang Abstract Syntax Tree}\label{sub:core_erlang_ast}

The Core Erlang Abstract Syntax Tree has a dual representation in the Erlang
compiler. The core parts of the compiler use the records defined in the file
\texttt{lib/compiler/core\textunderscore parse.hrl}, whereas 
\texttt{cerl\textunderscore inline} and all the modules in
\texttt{lib/hipe/cerl} use the Abstract Data Type defined in 
\texttt{lib/compiler/cerl.erl}. Essentially, both definitions are the same 
and can be used interchangeably so the decision on which representation to 
use boils down to the personal preference and style of the programmer. The 
records’ representation allows for easier decomposition of the syntax 
tree nodes by using pattern matching whereas the ADT representation offers 
a more formal approach that favours parse transformations. We decided to use 
the records’ representation as pattern matching greatly facilitates 
our implementation of the Core Erlang interpreter.

We feel that since the lexical analysis and grammar of Core Erlang are
presented in detail in the Core Erlang language specification 
paper~\cite{core_erlang_specs}, we should rather present the undocumented 
definitions of the Core Erlang Abstract Syntax Tree in 
\texttt{lib/compiler/core\textunderscore parse.hrl} and discuss their semantics 
in the context of their current usage in the Erlang compiler. First of all, 
let’s note some principles that will apply for the rest of the subsection and
continue to present the AST records.

\begin{itemize}
  \item A Core Erlang AST is considered to be of type Tree which is a union of
    all the records we will describe.
  \item All the records have the \texttt{c\textunderscore} prefix.
  \item A special case is the record \texttt{c\textunderscore def}. Well, 
    it is not a record per se, but it is mentioned as one in 
    \texttt{core\textunderscore parse.hrl} to denote the type of some
    record fields. It actually is a tuple of two elements, let’s say \{T1, T2\},
    where T1 and T2 are of type Tree. It is used when we want to show that T1
    is defined by T2. We will see its exact uses as we describe the records in
    \texttt{core\textunderscore parse.hrl}.
  \item Every record has an annotation field which is initialized to the empty
    list. Annotations are a list of associations between constant literals and
    a phrase. They are optional and their interpretation is implementation
    dependent. For simplicity, we will always have an empty annotation list in
    our records.
  \item We will mention the term environment. An environment is simply a
    mapping from names to Erlang values. Every expression is evaluated in a
    given environment that binds variables and functions to their values.
  \item Every evaluation of an expression can terminate normally and produce a
    sequence of values or end unexpectedly and throw an exception.
\end{itemize}

\subsubsection{Root Node of a Syntax Tree}

The root of a syntax tree will always be a \texttt{c\textunderscore module} record (Listing~\ref{lst:core_erlang_c_module}). The basic unit that
is compiled is a module, a single source code file that consists of the module
name, the list of exported functions, some optional attributes, such as type
definitions and function specifications, and the definitions of the exported
and internal functions. 

%% c_module
\includecode[erlang]{lst:core_erlang_c_module}{The \texttt{c\textunderscore module} record definition}{%
  listings/core_erlang_records/c_module.erl
}

As we see, these correspond with the fields of the \texttt{c\textunderscore module} record. The \texttt{name}
field is always a \texttt{c\textunderscore literal} record that holds the name of the module. The
\texttt{exports} field is a list of \texttt{c\textunderscore var} records that hold the names and arities of the
exported functions. The \texttt{attrs} field is a list of the aforementioned
\texttt{c\textunderscore def} constructs. In this case, each \texttt{c\textunderscore def} consists of two
\texttt{c\textunderscore literal} records. The first one denotes the type of
attribute (spec, type etc.) and the second one
its definition. The interpretation of module attributes is implementation
specific and we will discuss some of its uses in detail in Section~\ref{sec:erlang_types_specs}. The
\texttt{defs} field is also a list of \texttt{c\textunderscore def} constructs. The
first element of each \texttt{c\textunderscore def} is a \texttt{c\textunderscore var} record
that represents the name and arity of the defined function. The second element
is a \texttt{c\textunderscore fun} record that holds the definition of the respective
function.

\subsubsection{Expressions}

%% c_values
\emph{Ordered sequence of single expressions} (Listing~\ref{lst:core_erlang_c_values}).
With the term single expression we mean that we want an expression that its
evaluation will yield a value. An ordered sequence is the result of evaluating an 
expression and is by no means a value per se, meaning that we cannot have a sequence of 
sequences. The length of the \texttt{es} list denotes the degree of the sequence.

\includecode[erlang]{lst:core_erlang_c_values}{The \texttt{c\textunderscore values} record definition}{%
  listings/core_erlang_records/c_values.erl
}

%% c_literal
\emph{Atomic literal} (Listing~\ref{lst:core_erlang_c_literal}).
The \texttt{c\textunderscore literal} record holds a literal, a notation of constant 
value such as an integer or an atom. It represents the Erlang value 
denoted by that literal.

\includecode[erlang]{lst:core_erlang_c_literal}{The \texttt{c\textunderscore literal} record definition}{%
  listings/core_erlang_records/c_literal.erl
}

%% c_var
\emph{Variable name} (Listing~\ref{lst:core_erlang_c_var}).
The \texttt{name} field can be an integer() or an atom() (variable’s name) or a \{atom(),
integer()\} (function’s name and arity). It evaluates to the value that is bound
to the variable or function in the current environment. We should mention that
when it comes to a function, the value that we expect is a closure.

\includecode[erlang]{lst:core_erlang_c_var}{The \texttt{c\textunderscore var} record definition}{%
  listings/core_erlang_records/c_var.erl
}

%% c_tuple
\emph{Erlang tuple} (Listing~\ref{lst:core_erlang_c_tuple}).
The \texttt{c\textunderscore tuple} record holds a list of n expressions. 
This evaluates to the Erlang n-tuple where each element is the result 
of the evaluation of the respective expression of the \texttt{es} list 
in the current environment. If the \texttt{es} field is an empty list, 
then the result is the 0-tuple \{\}.

\includecode[erlang]{lst:core_erlang_c_tuple}{The \texttt{c\textunderscore tuple} record definition}{%
  listings/core_erlang_records/c_tuple.erl
}

%% c_cons
\emph{Erlang list constructor} (Listing~\ref{lst:core_erlang_c_cons}).
Let \texttt{e} be the current environment. The \texttt{hd} field is the expression 
that evaluates to the head of the cons cell in \texttt{e}. The \texttt{tl} field 
is the expression that evaluates to the tail of the cons cell in \texttt{e}.

\includecode[erlang]{lst:core_erlang_c_cons}{The \texttt{c\textunderscore cons} record definition}{%
  listings/core_erlang_records/c_cons.erl
}

%% c_binary
\emph{Erlang binary} (Listing~\ref{lst:core_erlang_c_binary}).
The \texttt{segments} field is a list of \texttt{c\textunderscore bitstr} records 
that each evaluates to an Erlang bitstring. The value of the 
\texttt{c\textunderscore binary} is the concatenation of these individual
bitstrings in the order defined in the segments list. All the segments are
evaluated in same environment as the \texttt{c\textunderscore binary} record.

\includecode[erlang]{lst:core_erlang_c_binary}{The \texttt{c\textunderscore binary} record definition}{%
  listings/core_erlang_records/c_binary.erl
}

%% c_bitstr
\emph{Erlang bitstring} (Listing~\ref{lst:core_erlang_c_bitstr}).
The \texttt{val} field specifies a value to be encoded as a bitstring, whereas the rest
of the fields control the encoding. These control fields are evaluated at load time 
so they ought to be \texttt{c\textunderscore literal} records. This limitation has 
complicated the implementation of the Core Erlang interpreter and its effect will 
be discussed in chapter~\ref{ch:cuter}. The \texttt{size} field is evaluated either 
to a non negative integer or to the atom \texttt{‘all’}. The \texttt{unit} field 
evaluates to number between 1 and 256. The \texttt{type} field evaluates to either integer, 
float or binary. The \texttt{flags} field evaluates to a list that contains a value for 
the signedness (signed or unsigned) and a value for the endianess (big, little or native) 
of the bitstring. The specifics of the encoding will be discussed when we present the 
Erlang Type System in section~\ref{sec:erlang_types_specs}.

\includecode[erlang]{lst:core_erlang_c_bitstr}{The \texttt{c\textunderscore bitstr} record definition}{%
  listings/core_erlang_records/c_bitstr.erl
}

%% c_let
\emph{Let definition} (Listing~\ref{lst:core_erlang_c_let}).
First of all, we evaluate the expression that is held in the \texttt{arg} field in the
current environment \texttt{e}. This evaluation yields a sequence of \texttt{n} values 
\texttt{s}. We then expect a list of \texttt{n} \texttt{c\textunderscore var} records 
in the \texttt{vars} field that represent the variables that are to be bound. We then bind 
these variables to their respective value in the sequence \texttt{s} and add them to the 
current environment \texttt{e} thus creating the new environment \texttt{e’}. The value 
of the whole let expression is the evaluation of the expression of the \texttt{body} field 
in the new environment \texttt{e’}.

\includecode[erlang]{lst:core_erlang_c_let}{The \texttt{c\textunderscore let} record definition}{%
  listings/core_erlang_records/c_let.erl
}

%% c_seq
\emph{Sequence of expressions} (Listing~\ref{lst:core_erlang_c_seq}).
This record is syntactic sugar for a \texttt{c\textunderscore let} without a
\texttt{vars} field. Its only purpose is to evaluate the expression of the
\text{arg} field before the expression of the \texttt{body} field. Both
expressions are evaluated in the current environment.

\includecode[erlang]{lst:core_erlang_c_seq}{The \texttt{c\textunderscore seq} record definition}{%
  listings/core_erlang_records/c_seq.erl
}

%% c_record
\emph{Case statement} (Listing~\ref{lst:core_erlang_c_case}).
This is the main control flow construct (along with \texttt{c\textunderscore receive}). We begin with
evaluating the expression of the \texttt{arg} field in the current environment which
yields a sequence of values. Then, this sequence is matched against each of the
clauses in the \texttt{clauses} field list until one of them succeeds. It is certain
that at least one will succeed since the compiler adds a catch-all clause at
the end of every non-exhaustive case statement that will raise the appropriate
exception. The order of the clauses is important since only the first one that
matched will be selected. For what happens when a clause is selected, refer to
the explanation of the \texttt{c\textunderscore clause} record.

\includecode[erlang]{lst:core_erlang_c_case}{The \texttt{c\textunderscore case} record definition}{%
  listings/core_erlang_records/c_case.erl
}

%% c_fun
\emph{Function definition} (Listing~\ref{lst:core_erlang_c_fun}).
The \texttt{vars} field containts a list of \texttt{c\textunderscore var} records that 
denote the parameters of the function. The \texttt{body} field contains an expression 
that defines the body of the function. A \texttt{c\textunderscore fun} is used to 
define three types of functions.

\begin{itemize}
  \item An exported or internal function of a model
  \item An anonymous function
  \item A function that is bound in a letrec statement
\end{itemize}

In all three cases, the \texttt{c\textunderscore var} evaluates to the closure that is 
defined by abstracting the expression in the \texttt{body} field with respect to the 
parameters in the \texttt{vars} field in the current environment.

\includecode[erlang]{lst:core_erlang_c_fun}{The \texttt{c\textunderscore fun} record definition}{%
  listings/core_erlang_records/c_fun.erl
}

%% c_letrec
\emph{Letrec statement} (Listing~\ref{lst:core_erlang_c_letrec}).
We must note that only functions can be bound by a Core Erlang \texttt{letrec} statement.
Therefore, the \texttt{c\textunderscore def} we encounter in \texttt{defs} field list has a 
\texttt{c\textunderscore var} as its first element that denotes the name and arity of the 
function that is to be bound. The second element is a \texttt{c\textunderscore fun} record 
that holds the definition of the particular function. Once we bind all the functions to 
their definitions and add them to the current environment \texttt{e}, we evaluate the expression 
of the \texttt{body} field in the resulting environment \texttt{e’}.

The definition of \texttt{e’} can be a little tricky. The environment \texttt{e’} is the smallest
environment such that:

\begin{itemize}
  \item contains all the elements of \texttt{e}, except for the functions that will be
    bound by the \texttt{letrec},
  \item and every such function will be evaluated in \texttt{e’} itself.
\end{itemize}

This is a circular definition and its implementation requires a recursive
environment. Essentially, we need an environment that arranges to evaluate the
values for its bindings in an environment where the bindings are already in
place. We will discuss how we implemented this feature in chapter~\ref{ch:cuter}.

\includecode[erlang]{lst:core_erlang_c_letrec}{The \texttt{c\textunderscore letrec} record definition}{%
  listings/core_erlang_records/c_letrec.erl
}

%% c_apply
\emph{Function application} (Listing~\ref{lst:core_erlang_c_apply}).
The \texttt{op} field contains the expression that will evaluate to a closure \texttt{f} in the
current environment. The \texttt{args} field contains a list of \texttt{n} expressions that will
evaluate to \texttt{n} values respectively that will comprise the argument list of the
closure. The result of the expression is the application of the argument list
to the closure \texttt{f}. It is expected that the arity of the closure \texttt{f} will be the
same as the length of the argument list.

\includecode[erlang]{lst:core_erlang_c_apply}{The \texttt{c\textunderscore apply} record definition}{%
  listings/core_erlang_records/c_apply.erl
}

%% c_call
\emph{Module-qualified function call} (Listing~\ref{lst:core_erlang_c_call}).
The \texttt{module} and \texttt{name} fields contain the information of the function with an
explicit module, function name, and arity (MFA) that will be called. They both
evaluate to atoms. The \texttt{args} field contains a list of expressions that each is
evaluated in the current environment. The resulting list of values will be
passed as the argument list of the MFA. It is essential that the MFA is in its
module’s exported list.

\includecode[erlang]{lst:core_erlang_c_call}{The \texttt{c\textunderscore call} record definition}{%
  listings/core_erlang_records/c_call.erl
}

%% c_primop
\emph{Primitive operation} (Listing~\ref{lst:core_erlang_c_primop}).
The \texttt{args} field contains a list of expressions that are evaluated in the current
environment and yield a list of values respectively. The \texttt{name} field contains
the primitive operation (mainly a \texttt{c\textunderscore var}) to be performed. We then apply the
list of values to the primitive operator to get the value of the whole
expression.

The evaluation of a primitive operation is implementation dependent and may
depend on many things, like the internal state of the process, the external
state of the world etc. A common case where primitive operations are used in is
bit comprehensions.

\includecode[erlang]{lst:core_erlang_c_primop}{The \texttt{c\textunderscore primop} record definition}{%
  listings/core_erlang_records/c_primop.erl
}

%% c_try
\emph{Try–catch statement} (Listing~\ref{lst:core_erlang_c_try}).
The \texttt{arg} field contains the main expression that we will try to evaluate
in the current environment \texttt{e}. Depending on the result of this
evaluation we have two alternatives:

\begin{enumerate}
  \item The evaluation completes normally and yields a sequence of values.
    Then, we bind these values to the list of variables contained in the
    \texttt{vars} field and add these bindings to \texttt{e} thus creating the
    environment \texttt{e'}. The result of the try-catch expression is the result of the evaluation of the expression of the \texttt{body} field in the environment \texttt{e'}.
  \item The evaluation stops abruptly raising an exception. Then, we bind the
    exception to the list of variables contained in the \texttt{evars} field
    and add these bindings to \texttt{e} thus creating the environment
    \texttt{e''}. The result of the try-catch expression is the result of the evaluation of the expression of the \texttt{handler} field in the environment \texttt{e''}.
\end{enumerate}

\includecode[erlang]{lst:core_erlang_c_try}{The \texttt{c\textunderscore} try record definition}{%
  listings/core_erlang_records/c_try.erl
}

%% c_catch
\emph{Catch statement} (Listing~\ref{lst:core_erlang_c_catch}).
This is syntactic sugar for a \texttt{c\textunderscore try} with only the \texttt{body} field. This works as follows:
We evaluate the \texttt{body} expression in the current environment and monitor its evaluation. There are two alternatives:

\begin{enumerate}
  \item If the evaluation completed normally, the value of the whole expression is the value of the \texttt{body}.
  \item If the evaluation stops abruptly and yields an exception, we do one of the following:
    \begin{enumerate}
      \item If it is a \texttt{throw} exception, we return the reason of the
        exception \texttt{r}.
      \item If it is an \texttt{exit} exception, we return the reason of the
        exception \texttt{r} wrapped in the tuple \texttt{\{'EXIT', r\}}.
      \item If it is an \texttt{error} exception, we return the reason of the
        exception \texttt{r} along with the stacktrace \texttt{s} wrapped in
        the tuple \texttt{\{'EXIT', r, s\}}.
    \end{enumerate}
\end{enumerate}

\includecode[erlang]{lst:core_erlang_c_catch}{The \texttt{c\textunderscore catch} record definition}{%
  listings/core_erlang_records/c_catch.erl
}

%% c_receive
\emph{Receive expression} (Listing~\ref{lst:core_erlang_c_receive}).
This is the second type of control flow construct that exists in Core Erlang.
Its evaluation is a bit complex thus is divided into stages.

\begin{enumerate}
  \item The \texttt{timeout} field contains the expiry expression, which the
    first thing we evaluate in the current environment \texttt{e}. It may yield a non
    negative integer \texttt{t} or the atom \texttt{'infinity'}. If the result
    is not \texttt{'infinity'}, we start a timer that expires in \texttt{t}
    milliseconds.
  \item\label{itm:recv-stage-2} Then, we run through the process's mailbox from start to end and try
    to match a message against one of the clauses in the \texttt{clauses} list
    field in the current environment \texttt{e}. This may have two outcomes:
    \begin{enumerate}
      \item A message matches one of the clauses and yields some mappings that
        are added to \texttt{e} to create the environment \texttt{e'}. Then, this
        message is deleted from the mailbox and we evaluate the
        expression indicated by the matched clause in the environment \texttt{e'}.
      \item We tried all the current messages but none matched any of the
        clauses. If the expiry expression evaluated to 0 or the timer has
        expired, we evaluate the expression of the \texttt{action} field in
        \texttt{e}. Otherwise, we suspend the evaluation.
    \end{enumerate}
  \item The evaluation is recovered if a message has arrived to the mailbox or
    if the timer has expired. In the former scenario we re-enter stage~\ref{itm:recv-stage-2},
    whereas in the latter one we evaluate the expression of the \texttt{action}
    field in \texttt{e}.
\end{enumerate}

\includecode[erlang]{lst:core_erlang_c_receive}{The \texttt{c\textunderscore receive} record definition}{%
  listings/core_erlang_records/c_receive.erl
}

\subsubsection{Clauses and Pattern Matching}

%% c_clause
\emph{Clause template} (Listing~\ref{lst:core_erlang_c_clause}).
This record describes the template of a Core Erlang clause. The \texttt{pats}
field contains the sequence of patterns that will be tried, in left-to-right order,
against the sequence of values so as to determine if the clause matches the
sequence. The patterns are evaluated in the current environment \texttt{e}.

\begin{itemize}
  \item If the patterns and the sequence of values matched, some new bindings
    may have been generated which added to \texttt{e} will create the new
    environment \texttt{e'}. We then evaluate the expression of the
    \texttt{guard} field. 
    \begin{itemize}
      \item If the result is \texttt{'true'}, the clause has been definitively
        matched thus we continue to evaluate the expression of the
        \texttt{body} field in the environment \texttt{e'}.
      \item If the result is \texttt{'false'}, the clause does not match so we
        move on to the next clause.
    \end{itemize}
  \item If the patterns did not match the sequence, the next clause in order is
    tried.
\end{itemize}

\includecode[erlang]{lst:core_erlang_c_clause}{The \texttt{c\textunderscore clause} record definition}{%
  listings/core_erlang_records/c_clause.erl
}

A pattern is represented by the following records:

\begin{itemize}
  \item A \texttt{c\textunderscore literal} record represents an atomic literal pattern.
  \item A \texttt{c\textunderscore var} record represents a variable name pattern.
  \item A \texttt{c\textunderscore tuple} record represents a tuple pattern.
  \item A \texttt{c\textunderscore cons} record represents a list constructor pattern.
  \item A \texttt{c\textunderscore binary} record represents a binary pattern.
  \item A \texttt{c\textunderscore alias} record (Listing~\ref{lst:core_erlang_c_alias}) represents an alias pattern.
    The \texttt{pat} field contains the pattern that will be matched against a
    value \texttt{v}. If the match succeeds then a mapping is generated that
    binds the variable of the \texttt{var} field to \texttt{v}. If not, the
    whole match fails.
\end{itemize}

%% c_alias
\includecode[erlang]{lst:core_erlang_c_alias}{The \texttt{c\textunderscore alias} record definition}{%
  listings/core_erlang_records/c_alias.erl
}

\section{Erlang Types and Function Specifications}\label{sec:erlang_types_specs}

Erlang is a dynamically typed language. Type information exists in any piece of
data and is checked during every operation at runtime so as to provide type
safety. There are primitive types built in the language that can be combined by
the programmer to create custom ones. There is even a notation for declaring
the type specification of a function concerning its intended use. This piece of
information is critical for an effective testing tool since it will report bugs
relevant to the program's actual use~\cite{papadakis10}. We will briefly describe the types in
Erlang and the function specifications and focus on its representation in the
Core Erlang Abstract Syntax Tree.

Any piece of data in Erlang is called a term. A term can belong to a predefined
(or built-in) type or to a user-defined type constructed from the predefined
ones. 

\subsection{Predefined Types}\label{sub:predef_types}

The predefined types are the following:

\begin{itemize}
  \item \emph{Integer}. An integer is a numeric literal.
  \item \emph{Float}. A float is a numeric literal as well.
  \item \emph{Atom}. An atom is a literal, a named constant.
  \item \emph{Bit string and binary}. A bit string is a series of bytes stored
    in an area of untyped memory. If the number of bits is divisible by eight,
    it is also a binary.
  \item \emph{Reference}. A reference is a term which is unique in an Erlang
    runtime system.
  \item \emph{Fun}. A fun is callable function object represented with a
    closure.
  \item \emph{Port identifier}. A port identifier identifies an Erlang port.
  \item \emph{Pid}. A pid, or process identifier, is a handle that uniquely
    identifies an Erlang process.
  \item \emph{Tuple}. A tuple is a compound data type with a fixed number of
    terms (not necessarily of the same type).
  \item \emph{List}. A list is a compound data type with a variable number of
    terms (not necessarily of the same type).
\end{itemize}

There are also some types that are defined in terms of the above primitives and
are essentially syntactic sugar.

\begin{itemize}
  \item \emph{Number}. A number is either an integer or a float.
  \item \emph{Char}. A char is an integer in the range from 0 to 1114111.
  \item \emph{String}. A string is shorthand for a list of chars.
  \item \emph{Record}. A record is actually a tuple with an atom as its first
    element. Records are declared with \texttt{-record} compiler attribute and
    are converted to tuples at compile time.
  \item \emph{Boolean}. There is no boolean type in Erlang. However, the atoms
    \texttt{'true'} and \texttt{'false'} have a special use for acting as
    boolean values.
\end{itemize}

\subsection{User Defined Types}\label{sub:userdef_types}

Erlang allows the programmer to define his own types using the \texttt{-type}
and \texttt{-opaque} compiler attributes. User defined types are often useful
for parametric or recursive types and may serve as type aliases.

The basic syntax of a type is an atom, i.e. the type's name, followed by closed
parentheses. Type declarations can also be parametrized by including type
variables between the parentheses, used for parametric types. The definition is
a valid type expression (Subsection~\ref{sub:type_notation}). Let's note that
users are not allowed to define types with the same names and arity as the
predefined or built-in ones.

\subsection{Representation of the Types on the Core Erlang AST}\label{sub:type_notation}

Type expressions are used in type definitions and function specifications. In
this subsection we will describe the notation for writing type expressions and
we will see how the compiler transforms them into the Core Erlang AST.

We should note that the Erlang compiler stores debug information containing the
source code's line numbers in the AST. Thus, you will see the symbol
\texttt{Ln} used in the Core Erlang AST representation of the type notation,
which denotes the line number it refers to in the source code file.

\subsubsection{Notation of Predefined Types}\label{subsub:notation_predef_types}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|c|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|}
    \hline
      Type Notation & Description & Core Erlang Representation \\
    \hline \hline
      \emph{integer()} & Any Erlang integer & \texttt{\{type, Ln, integer, []\}} \\
    \hline
      \emph{<Int>}
      & Singleton integer type (only the specific \emph{<Int>})
      & \texttt{\{integer, Ln, <Int>\}} \\
    \hline
      \emph{<Lo>...<Hi>}
      & Integers in the range from \emph{<Lo>} to \emph{<Hi>}
      & \texttt{\{type, Ln, range, [Lo, Hi]\}} where \texttt{Low :: \{integer, Ln, <Lo>\}}, \texttt{High :: \{integer, Ln, <Hi>\}} \\ 
    \hline
      \emph{neg\textunderscore integer()}
      & Any negative Erlang integer
      & \texttt{\{type, Ln, neg\textunderscore integer, []\}} \\
    \hline
      \emph{non\textunderscore neg\textunderscore integer()}
      & Any non-negative Erlang integer
      & \texttt{\{type, Ln, non\textunderscore neg\textunderscore integer, []\}} \\
    \hline
      \emph{pos\textunderscore integer()}
      & Any positive Erlang integer
      & \texttt{\{type, Ln, pos\textunderscore integer, []\}} \\
    \hline
      \emph{float()} & Any Erlang float & \texttt{\{type, Ln, float, []\}} \\
    \hline
  \end{tabularx}
  \caption{Notation of numeric types}
  \label{tab:notation_numeric_types}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|c|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|}
    \hline
      Type Notation & Description & Core Erlang Representation \\
    \hline \hline
      \emph{tuple()} & Any Erlang tuple & \texttt{\{type, Ln, tuple, any\}} \\
    \hline
      \{\}
      & Singleton tuple type (only the 0-tuple)
      & \texttt{\{type, Ln, tuple, []\}} \\
    \hline
      \{\emph{Type\textsubscript{1},...,Type\textsubscript{N}}\}
      & An tuple of N elements of types \emph{Type\textsubscript{1},...,Type\textsubscript{N}} respectively
      & \texttt{\{type, Ln, tuple, [T\textsubscript{1},...,T\textsubscript{N}]\}} where \texttt{T\textsubscript{i}} is a valid type expression \\
    \hline
  \end{tabularx}
  \caption{Notation of tuples}
  \label{tab:notation_tuples}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|c|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|}
    \hline
      Type Notation & Description & Core Erlang Representation \\
    \hline \hline
      \emph{list()} & Any Erlang list & \texttt{\{type, Ln, list, []\}} \\
    \hline
      \emph{nonempty\textunderscore list()} 
      & Any Erlang non-empty list 
      & \texttt{\{type, Ln, nonempty\textunderscore list, []\}} \\
    \hline
      [] & Singleton list type (only the empty list) & \texttt{\{type, Ln, nil, []\}} \\
    \hline
      [\emph{Type\textsubscript{1}}|\emph{...}|\emph{Type\textsubscript{N}}]
      & An list of elements of types \emph{Type\textsubscript{1},...,Type\textsubscript{N}}
      & \texttt{\{type, Ln, list, [T\textsubscript{1},...,T\textsubscript{N}]\}} where \texttt{T\textsubscript{i}} is a valid type expression \\
    \hline
      [\emph{Type\textsubscript{1}}|\emph{...}|\emph{Type\textsubscript{N}}, \emph{...}]
      & An non-empty list of elements of types \emph{Type\textsubscript{1},...,Type\textsubscript{N}}
      & \texttt{\{type, Ln, nonempty\textunderscore list, [T\textsubscript{1},...,T\textsubscript{N}]\}}  where \texttt{T\textsubscript{i}} is a valid type expression \\
    \hline
  \end{tabularx}
  \caption{Notation of lists}
  \label{tab:notation_lists}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|c|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|}
    \hline
      Type Notation & Description & Core Erlang Representation \\
    \hline \hline
      \emph{bitstring())} & Any Erlang bitstring & \texttt{\{type, Ln, bitstring, []\}} \\
      \emph{binary()} & Any Erlang binary & \texttt{\{type, Ln, binary, []\}} \\
%      \emph{<<>>} & An empty bitstring & \texttt{\{type, Ln, binary, [\{integer, Ln, 0\}, \{integer, Ln, 0\}]\}} \\
      \emph{<<\textunderscore :M>>} & A bitstring that is M bits long & 
        \texttt{\{type, Ln, binary, [\{integer, Ln, M\}, \{integer, Ln, 0\}]\}} \\
      \emph{<<\textunderscore :\textunderscore *N>>} & A bitstring that is (k*N) bits long & 
        \texttt{\{type, Ln, binary, [\{integer, Ln, 0\}, \{integer, Ln, N\}]\}} \\
      \emph{<<\textunderscore :M, \textunderscore :\textunderscore *N>>} & A bitstring that is M + (k*N) bits long & 
        \texttt{\{type, Ln, binary, [\{integer, Ln, M\}, \{integer, Ln, N\}]\}} \\
    \hline
  \end{tabularx}
  \caption{Notation of binaries and bit strings}
  \label{tab:notation_binary_types}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|c|>{\centering\arraybackslash}X|>{\arraybackslash}X|}
    \hline
      Type Notation & Description & Core Erlang Representation \\
    \hline \hline
      \emph{fun()} & Any Erlang function & \texttt{\{type, Ln, fun, []\}} \\
      \emph{fun((...) -> Type)} & A function of any arity that returns Type & 
        \texttt{\{type, Ln, fun, [\{type, Ln, any\}, \{type, Ln, Type, []\}]\}} \\
      \emph{fun(() -> Type)} & A function of 0 arity that returns Type & 
        \texttt{\{type, Ln, fun, [\{type, Ln, product, []\}, \{type, Ln, Type, []\}]\}} \\
      \emph{fun((Tlist) -> Type)} & A function with Tlist as arguments that returns Type & 
        \texttt{\{type, Ln, fun, [\{type, Ln, product, Tlist\}, \{type, Ln, Type, []\}]\}} \\
    \hline
  \end{tabularx}
  \caption{Notation of function types}
  \label{tab:notation_funs}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|c|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|}
    \hline
      Type Notation & Description & Core Erlang Representation \\
    \hline \hline
      \emph{term()} & \multirow{2}*{Any Erlang term} & \texttt{\{type, Ln, term, []\}} \\
    \cline{1-1} \cline{3-3}
      \emph{any()} & & \texttt{\{type, Ln, any, []\}} \\
    \hline
      \emph{none()} & No type & \texttt{\{type, Ln, none, []\}} \\
    \hline
      \emph{no\textunderscore return()} 
      & No return type (Used when an exception is raised) 
      & \texttt{\{type, Ln, no\textunderscore return, []\}} \\
    \hline
      \emph{Type\textsubscript{1}} | \emph{...} | \emph{Type\textsubscript{N}}
      & An union of N terms of types \emph{Type\textsubscript{1},...,Type\textsubscript{N}} respectively
      & \texttt{\{type, Ln, union, [T\textsubscript{1},...,T\textsubscript{N}]\}} where \texttt{T\textsubscript{i}} is a valid type expression \\
    \hline
      \emph{atom()} & Any Erlang atom & \texttt{\{type, Ln, atom, []\}} \\
    \hline
      \emph{<Atom>}
      & Singleton atom type (only the specific \emph{<Atom>})
      & \texttt{\{atom, Ln, <Atom>\}} \\
    \hline
      \emph{reference()} & Any Erlang reference & \texttt{\{type, Ln, reference, []\}} \\
    \hline
      \emph{port()} & Any Erlang port identifier & \texttt{\{type, Ln, port, []\}} \\
    \hline
      \emph{pid()} & Any Erlang process identifier & \texttt{\{type, Ln, pid, []\}} \\
    \hline
  \end{tabularx}
  \caption{Notation of other useful types}
  \label{tab:notation_other}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|c|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|}
    \hline
      Type Notation & Description & Core Erlang Representation \\
    \hline \hline
      \emph{number()} & Any Erlang integer or float & \texttt{\{type, Ln, number, []\}} \\
    \hline
      \emph{char()} & Any Erlang char & \texttt{\{type, Ln, char, []\}} \\
    \hline
      \emph{string()} & Any Erlang string & \texttt{\{type, Ln, string, []\}} \\
    \hline
      \emph{nonempty\textunderscore string()} 
      & Any non-empty Erlang string 
      & \texttt{\{type, Ln, nonempty\textunderscore string, []\}} \\
    \hline
      \emph{boolean()} 
      & One of the atoms \texttt{'true'} or \texttt{'false'}
      & \texttt{\{type, Ln, boolean, []\}} \\
    \hline
      \emph{byte()} 
      & Any integer in the range from 0 to 255
      & \texttt{\{type, Ln, byte, []\}} \\
    \hline
      \emph{node()} & An atom that represents an Erlang VM node & \texttt{\{type, Ln, node, []\}} \\
    \hline
      \emph{module()} & An atom that represents a module & \texttt{\{type, Ln, module, []\}} \\
    \hline
     \emph{mfa()} 
     & An tuple that represents an Erlang MFA (\{\emph{Module, Function, Arity}\})
     & \texttt{\{type, Ln, mfa, []\}} \\
    \hline
  \end{tabularx}
  \caption{Notation of aliases for other types}
  \label{tab:notation_aliases}
\end{table}

\subsubsection{Notation of User Defined Types}\label{subsub:notation_userdef_types}

We have mentioned that the root element of a Core Erlang AST is a
\texttt{c\textunderscore module} record. The \texttt{attrs} field contains a
list of \texttt{c\textunderscore def} records concerning implementation
specific information. One type of such information is the declaration of a user
defined type or a record. Let's call such a \texttt{c\textunderscore def}
record, a \texttt{TypeAttrDef}. In Table~\ref{tab:notation_userdef_recs} we can see
the basic syntax of a \texttt{TypeAttrDef}.

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|p{2cm}X|}
    \hline
      \texttt{TypeAttrDef} 
        & \texttt{:: \{\{c\textunderscore literal, Ln, type\}, \{c\textunderscore literal, Ln, [TypeAttr]\}\}} \\
      \texttt{TypeAttr} 
        & \texttt{:: RecordDef | TypeDef} \\
      \texttt{RecordDef}
        & \texttt{:: \{\{record, RecordName :: atom()\}, (RecordField)+, []\}} \\
      \texttt{RecordField}
        & \texttt{:: UntypedRF | TypedRF} \\
      \texttt{UntypedRF}
        & \texttt{:: \{record\textunderscore field, Ln, FldName :: atom()\}} \\
        & \texttt{ | \{record\textunderscore field, Ln, FldName :: atom(), DefVal :: term()\}} \\
      \texttt{TypedRF} 
        & \texttt{:: \{typed\textunderscore record\textunderscore field, UntypedRF, Type\}} \\
      \texttt{TypeDef} 
        & \texttt{:: \{TypeName :: atom(), Type, (FreeVar)*\}} \\
      \texttt{FreeVar} 
        & \texttt{:: \{var, Ln, VarName :: atom()\}} \\
      \texttt{Type}
        & \texttt{::} Valid Type Representation \\
    \hline
  \end{tabularx}
  \caption{Basic Grammar of a \texttt{TypeAttrDef}}
  \label{tab:notation_userdef_recs}
\end{table}

\subsection{Function Specifications}\label{sub:func_specs}

A function specification is a contract which explicitly states the programmer's
intented use for a function. It is declared using the \texttt{-spec} compiler
attribute. The basic syntax is the following:

\centerline{\texttt{-spec Fun(ArgType\textsubscript 1, ArgType\textsubscript 2, ..., ArgType\textsubscript N) $\rightarrow$ ReturnType}}

There are also other ways of stating a function specification which are
variants of the basic one. They may be used for documentation purposes, to
express overloaded specifications etc. They are described in detail
in the Erlang Type Specifications~\cite{erlang_typespec}.

The information of a function's specification is stored in Core Erlang AST. You
can find it as a \texttt{c\textunderscore def} in the \texttt{attrs} field of
the root \texttt{c\textunderscore module} record, which we'll call
\texttt{SpecAttrDef}. In Table~\ref{tab:notation_func_specs} we can see the
basic syntax of a \texttt{SpecAttrDef}.

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|p{2cm}X|}
    \hline
      \texttt{SpecAttrDef} 
        & \texttt{:: \{\{c\textunderscore literal, Ln, spec\}, \{c\textunderscore literal, Ln, [SpecAttr]\}\}} \\
      \texttt{SpecAttr} 
        & \texttt{:: \{\{F :: atom(), A :: byte()\}, (Spec)+\}} \\
      \texttt{Spec} 
        & \texttt{:: Fun | BoundedFun} \\
      \texttt{Fun} 
        & \texttt{:: \{type, Ln, 'fun', [Product, Type]\}} \\
      \texttt{Product} 
        & \texttt{:: \{type, Ln, product, (Type)*\}} \\
      \texttt{BoundedFun} 
        & \texttt{:: \{type, Ln, bounded\textunderscore fun, [Fun, (Constraint)*]\}} \\
      \texttt{Constraint} 
        & \texttt{:: \{type, Ln, constraint, SubTypeCnst\}} \\
      \texttt{SubTypeCnst} 
        & \texttt{:: [\{atom, Ln, is\textunderscore subtype\}, [VarName :: atom(), Type]]} \\
      \texttt{Type}
        & \texttt{::} Valid Type Representation \\
    \hline
  \end{tabularx}
  \caption{Basic Grammar of a \texttt{SpecAttrDef}}
  \label{tab:notation_func_specs}
\end{table}
