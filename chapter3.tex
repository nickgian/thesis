\chapter{Control-Flow Integrity}\label{ch:cfi}

Restricting the control-flow of a program in some way is a technique widely
spread among security researchers. For example non-executable data (NXD)
can be considered as a form of (very) coarse-grained \CFI where control-flow is
not allowed to reach any memory region that holds non-executable data. Other
mitigation techniques such as protecting return addresses on the stack enforce
a form of coarse-grained \CFI.

Moreover it is common that security properties are enforced dynamically by code
that is statically injected to the program (\EG Inlined Reference Monitors (IRM)
\cite{Erlingsson04} follow that approach), thus some form of \CFI is required in
order to ensure that these checks are not circumvented. 

\TODO{Think about title}
\section{Related Work}

\subsection{Balancing between performance and security}\label{sec:security_cfi}

Abadi \ETAL first proposed a technique to enforce \CFI based on IRMs. 
In particular, they proposed to mark all valid targets of \emph{indirect} 
control transfers with a unique identifier and inject checks before all 
indirect jumps (including return instructions). However they assume that any 
two destinations are equivalent, in the sense that they share the same 
identifier, if the CFG contains edges from the same  set of sources, which may
significantly reduce the precision of the CFG. 
The authors also note that a 2-ID approach where one identifier is used for 
calls and another for returns could provide adequate security in many cases. 

The work of Abadi \ETAL sparked interest of researchers who tried to improve
some of the weaknesses of the initial implementation, usually by choosing 
between performance against precision and vice-versa.

Bletsch \ETAL \cite{Bletsch:2011:MCA:2076732.2076783} followed the work
of Abadi \ETAL, but changed their checking mechanism to perform the check
after the control flow transfer has occurred which, as the authors claim,
reduced the cache pressure and resulted in better performance. Precision remains
the same with the implementation of Abadi \ETAL.

Zhang \ETAL \cite{Zhang2013} proposed \emph{Compact Control Flow Integrity
and Randomization} (CCFIR), a new efficient way to enforce coarse-grained \CFI.
CCFIR collects all valid targets of indirect control-transfers and stores them
in a random order, in a protected section called ``Springboard section''. 
Indirect control-transfers are only allowed to addresses that are in the
Springboard. Their implementation uses a 3-ID approach where one identifier is
used for calls and the two other identifiers are for returns, separating them
between returns to sensitive and non-sensitive functions. Their implementation
also supports interaction between protected and un-protected modules, which
makes it an attractive solution to coarse-grained \CFI.

The above techniques are evaluated in \cite{outofcontrol_ieeesp2014} where
the authors demonstrate code-reuse attacks against binaries protected by
coarse-grained \CFI. These attacks illustrate the need for fine-grained
\CFI which however incurs a high runtime-overhead penalty making deployment
of such a mechanism unlikely.

\paragraph{Standard assumptions for effective \CFI}\label{sec:cfi_assumptions}

Most -if not all- \CFI implementations also come with a set of assumptions under
which \CFI holds. Two standard assumptions for all mechanisms that attempt to
enforce \CFI are:
\begin{itemize}
\item Non-Executable Data (\emph{NXD}), a security
mechanism that disallows execution of data. 
\item Non-Writable Code (\emph{NWC}). Changing the code of a
program would allow an attacker to circumvent dynamic checks.
\end{itemize}

Both assumptions are fairly standard for modern computers and are enforced
through hardware or software. In some cases \emph{NXD} can be lifted, but
additional security risks and complexity is not worth the minor advantages
offered by such an action.

Many implementations that attempt to do fine-grained \CFI also require that
identifiers used to mark nodes in the CFG are unique.

\subsection{Coarse-grained CFI Micro-Policy}\label{sec:cfi_coarse}

\ch{consider moving to appendix, or related work section}

We can use the PUMP to implement the coarse-grained \CFI mechanisms described
earlier. Suppose we want to implement 1-ID \CFI, we tag all indirect flow 
destinations and sources with a tag \MARK{} and the rest of the instructions as 
\UNMARK. Executing instructions that are sources of indirect flows, propagates
their instruction tag to the \pc. We then have to check that the tag on the
destination matches the tag on the tag on the \pc.

\begin{figure}[H]
\infrule[Mark]{
  \ii{op} \in \lbrace \ii{Jump}, \ii{Jal} \rbrace
  }{
  \frule{\ii{op}}{}{\MARK}{}{}{} {\MARK}{-}
  }
\bigskip

\infrule[Check]{
  \textit{op} \not \in \lbrace \textit{Jump},\textit{Jal} \rbrace
  }{
  \frule{\ii{op}}{\MARK}{\MARK}{}{}{} {\UNMARK}{-}
  }
\bigskip

\infrule[NoCheck]{
  \textit{op} \not \in \lbrace \textit{Jump},\textit{Jal} \rbrace
  }{
  \frule{\ii{op}}{\UNMARK}{\UNMARK}{}{}{} {\UNMARK}{-}
  }
\caption{Rules enforcing fine-grained \CFI, \NXD and \NWC}
\end{figure}

Rule \emph{Mark} is used in the case the opcode is Jump or Jal (the
only indirect jumps in the RISC machine we examine) and propagates the
\MARKname tag on the tag of the new \pc. Rule \emph{Check} applies
when the tag on the \pc is set to \MARKname and corresponds to a legal
destination and rule \emph{NoCheck} corresponds to any instruction
that is not a jump source or target.

We do not further study this coarse-grained approach as we consider it
ineffective since attacks against it has already been demonstrated in
\cite{outofcontrol_ieeesp2014}. Instead we are going to focus on
implementing and formalizing a fine-grained \CFI micro-policy.


\subsection{Formal verification of Control-Flow Integrity}\label{sec:cfi_verif}

In \cite{AbadiBEL09} Abadi \ETAL extended their original paper, with
-among other things- a more detailed formal study of \CFI. Their
formalization regarded a much simpler machine than the x86 omitting
all the complexity in modern systems. The machine has a few
instructions, a separate data memory and instruction memory which by
the operational semantics of the machine are non-executable and
non-writable (enforcing \NXD and \NWC by construction), and a small
set of registers.  Moreover, their attacker model permits arbitrary
changes to the data memory, arbitrary changes to all the registers but
a few distinguished ones that are used during the dynamic checks and
no changes to the instruction memory.  The authors proof that under
some assumptions \CFI is preserved for every step even in the presence
of an attacker as powerful as the one described above.  Their formal
study served as a guideline for the implementation, but as it is done
on paper their proofs cannot be machine checked. Furthermore, their
formalization omits less interesting but important details such as
instruction encoding and decoding which as shown in
\cite{MorrisettTTTG12} are far from trivial for the x86.

Machine-checked formal verification efforts include \cite{ZhaoLSR11},
which is a SFI formalization for the ARM architecture that also
enforces \CFI.  Their formalization was developed using the HOL
theorem prover and a program logic framework they created. However
their benchmarks report a 240\% runtime overhead. The authors of
\cite{CriswellDA14} claim partial proofs for a \CFI enforcement
mechanism focused on the kernel of an operating system. Their runtime
overhead can also reach 100\%.

\section{Fine-Grained Control-Flow Integrity Micro-Policy}\label{sec:cfi_fine}

The PUMP hardware allows us to avoid taking the difficult decision between
performance and security. As shown in \cite{pump_asplos2015}, we can enforce a
\emph{fine-grained} \CFI policy with an average runtime overhead of less than 3\%
(maximum overhead of less than 10\%), on the SPEC2006 benchmarks.

\ch{Shrink and polish this}
In our design, we take the standard approach and claim \CFI under \NXD and
\NWC\ch{make it clear that we ENFORCE \NXD and \NWC}.
We considered designs that lifted these assumptions but
we rejected them, for the time being, as there did not seem to be any
considerable advantage \IE{compatibility with self-modifying programs,
JIT compilers, \ETC} Allowing the code of the program to change, would in
practice require for the CFG to change as well, which unless done in
a controlled, ``safe'' way, would invalidate the enforcement of \CFI.
However, we do not have to rely on special hardware or software to enforce
\NXD and \NWC. We can achieve this easily and efficiently by
creating a separate\ch{could be separate, but we include it into
 the \CFI one} micro-policy.


The micro-policy we implemented and studied is a composition of a fine-grained
\CFI micro-policy and the \NWC, \NXD micro-policies explained above.

Our approach uses unique identifiers to tag the contents of the memory that 
correspond to sources and potential destinations of indirect flows according to
a binary relation (on the identifiers) $\mathcal{CFG}$.

%\ch{I have more intuition about addresses than about identifiers}
Consider the set of tags 
\TAGS{\DATA,\INSTR{\ii{id}}, \INSTR{\bot}} where \ii{id} is a unique identifier 
(\IE used to tag the contents of only one location in the memory).
\ch{maybe add more intuition: for instance, we can
  choose identifiers to be the addresses at which the
  instructions are stored + example (POPL)}
Adapting the rules from \ref{sec:nwc_nxd}, we shall use \DATAname to tag all 
contents in memory that are considered non-executable data, \INSTR{\ii{id}}
to tag all contents in memory that are considered executable instructions and 
are sources or targets of indirect control flows and \INSTR{$\bot$} to tag all
other instructions.
The rules to enforce \NWC and \NXD are intuitively the same and only
change to account for the splitting of the \INSTRname{} tag.

We follow the same idea as with coarse-grained \CFI, propagating the
instruction tag of instructions that are sources of indirect flows to
the tag on the \pc of the next state and upon execution of the next
instruction, checking that the tag on the \pc and on the instruction
are in some relation. In the case of coarse-grained \CFI we required
that they match but for fine-grained \CFI we require that they are in
the \CFG relation.

% \begin{figure}[!htpb]
% \begin{align}
%  & (Jump/Jal, -,-, -, -, -) \rightarrow (- ,-) 
%  \text{ if (n,m) } \in \CFGm \label{fine_rule1} \tag{1} \\
%  & (Jump/Jal, \DATA, \INSTR{m}, -, -, -) \rightarrow (\INSTR{m},-) 
%  \text{ if (n,m) } \in \CFGm \label{fine_rule2} \tag{2} \\
%  & (Store, \DATA, \INSTR{\_}, -, -, \DATA) \rightarrow (\DATA,\DATA) 
%  \label{fine_rule3} \tag{3} \\
%  & (Store, \INSTR{n}, \INSTR{m}, -, -, \DATA) \rightarrow (\DATA,\DATA)
%  \text{ if (n,m) } \in \CFGm \label{fine_rule4} \tag{4} \\
%  & (Store, -, -, -, -, \INSTR{\_}) \rightarrow \varnothing
%   \label{fine_rule5} \tag{5} \\
%  & (-, \INSTR{n}, \INSTR{m}, -, -, -) \rightarrow (\DATA,-)
%  \text{ if (n,m) } \in \CFGm \label{fine_rule6} \tag{6} \\
%  & (-, \DATA, \INSTR{m}, -, -, -) \rightarrow (\DATA,-) \label{fine_rule7} 
%  \tag{7}\\
%  & (-, -, -, -, -, -) \rightarrow \varnothing \label{fine_rule8} 
%  \tag{8}
% \end{align}
% \caption{Rules enforcing fine-grained \CFI, \NXD and \NWC}
% \end{figure}

\begin{figure}[H]
\infrule[Flow/Check]{
  \ii{op} \in \lbrace \ii{Jump}, \ii{Jal} \rbrace \andalso 
  (src,dst) \in \CFGm
  }{
  \frule{\ii{op}}{\INSTR{src}}{\INSTR{dst}}{}{}{} {\INSTR{dst}}{-}
  }
\bigskip

\infrule[Flow/NoCheck]{
  op \in \lbrace \textit{Jump},\textit{Jal} \rbrace
  }{
  \frule{\ii{op}}{\DATA}{\INSTR{dst}}{}{}{} {\INSTR{dst}}{-}
  }
\bigskip

\infrule[Store/Check]{
  (src,dst) \in \CFGm
  }{
  \frule{\ii{Store}}{\INSTR{src}}{\INSTR{dst}}{}{}{\DATA} {\DATA}{\DATA}
  }
\bigskip

\infrule[Store/NoCheck]{
  \textit{ti} \in \lbrace \INSTR{dst}, \INSTR{\bot} \rbrace
  }{
  \frule{\ii{Store}}{\DATA}{\textit{ti}}{}{}{\DATA} {\DATA}{\DATA}
  }
\bigskip

\infrule[Rest/Check]{
  \textit{opcode} \not \in \lbrace \textit{Jump}, \textit{Jal}, \textit{Store} 
  \rbrace \andalso (src,dst) \in \CFGm
  }{
  \frule{\textit{opcode}}{\INSTR{src}}{\INSTR{dst}}{}{}{} {\DATA}{-}
  }
\bigskip

\infrule[Rest/NoCheck]{
  \textit{opcode} \not \in \lbrace \textit{Jump}, \textit{Jal}, \textit{Store} 
  \rbrace \andalso
  \textit{ti} \in \lbrace \INSTR{dst}, \INSTR{\bot} \rbrace
  }{
  \frule{\textit{opcode}}{\DATA}{\textit{ti}}{}{}{} {\DATA}{-}
  }
\caption{Rules enforcing fine-grained \CFI, \NXD and \NWC}
\end{figure}

We note in the above rules that the tag on the \PCname is \DATAname when
no check for a control-flow violation is required and \INSTR{\textit{src}} where
\textit{src} is some id, when an indirect flow instruction was executed and a
check for a control-flow violation is required. An important observation is that
the rules above allow for one control-flow violation to occur, but disallow the
next step and therefore the machine will certainly halt after a violation.

If the PUMP hardware fetched the tag on the memory address the machine is
jumping to and passed it as an argument to input vector, as it does in the
case of a Store instruction, we would be able to enforce \CFI with no violations
at all. \TODO{It can't do that for efficiency reasons?}






