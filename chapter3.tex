\chapter{Control-Flow Integrity}\label{ch:cfi}

Restricting the control-flow of a program in some way is a technique widely
spread among security researchers. For example non-executable data (NXD)
can be considered as a form of (very) coarse-grained \CFI where control-flow is
not allowed to reach any memory region that holds non-executable data. Other
mitigation techniques such as protecting return addresses on the stack enforce
a form of coarse-grained \CFI.

Moreover it is common that security properties are enforced dynamically by code
that is statically injected to the program (\EG Inlined Reference Monitors (IRM)
\cite{Erlingsson04} follow that approach), thus some form of \CFI is required in
order to ensure that these checks are not circumvented. 

\TODO{Think about title}
\section{Balancing between performance and security}\label{sec:security_cfi}

Abadi \ETAL first proposed a technique to enforce \CFI based on IRMs. 
In particular, they proposed to mark all valid targets of \emph{indirect} 
control transfers with a unique identifier and inject checks before all 
indirect jumps (including return instructions). However they assume that any 
two destinations are equivalent, in the sense that they share the same 
identifier, if the CFG contains edges from the same  set of sources, which may
significantly reduce the precision of the CFG. 
The authors also note that a 2-ID approach where one identifier is used for 
calls and another for returns could provide adequate security in many cases. 

The work of Abadi \ETAL sparked interest of researchers who tried to improve
some of the weaknesses of the initial implementation, usually by choosing 
between performance against precision and vice-versa.

Bletsch \ETAL \cite{Bletsch:2011:MCA:2076732.2076783} followed the work
of Abadi \ETAL, but changed their checking mechanism to perform the check
after the control flow transfer has occurred which, as the authors claim,
reduced the cache pressure and resulted in better performance. Precision remains
the same with the implementation of Abadi \ETAL.

Zhang \ETAL \cite{Zhang2013} proposed \emph{Compact Control Flow Integrity
and Randomization} (CCFIR), a new efficient way to enforce coarse-grained \CFI.
CCFIR collects all valid targets of indirect control-transfers and stores them
in a random order, in a protected section called ``Springboard section''. 
Indirect control-transfers are only allowed to addresses that are in the
Springboard. Their implementation uses a 3-ID approach where one identifier is
used for calls and the two other identifiers are for returns, separating them
between returns to sensitive and non-sensitive functions. Their implementation
also supports interaction between protected and un-protected modules, which
makes it an attractive solution to coarse-grained \CFI.

The above techniques are evaluated in \cite{outofcontrol_ieeesp2014} where
the authors demonstrate code-reuse attacks against binaries protected by
coarse-grained \CFI. These attacks illustrate the need for fine-grained
\CFI which however incurs a high runtime-overhead penalty making deployment
of such a mechanism unlikely.

\subsection{Standard assumptions for effective \CFI}\label{sec:cfi_assumptions}

Most -if not all- \CFI implementations also come with a set of assumptions under
which \CFI holds. Two standard assumptions for all mechanisms that attempt to
enforce \CFI are:
\begin{itemize}
\item \emph{NXD} is an abbreviation for Non-Executable Data, a security
mechanism that disallows execution of data. 
\item \emph{NWC} stands for Non-Writable Code. Changing the code of a
program would allow an attacker to circumvent dynamic checks.
\end{itemize}

Both assumptions are fairly standard for modern computers and are enforced
through hardware or software. In some cases \emph{NXD} can be lifted, but
additional security risks and complexity is not worth the minor advantages
offered by such an action.

Many implementations that attempt to do fine-grained \CFI also require that
identifiers used to mark nodes in the CFG are unique.

\section{Formal verification of Control-Flow Integrity}\label{sec:cfi_verif}

In \cite{AbadiBEL09} Abadi \ETAL extended their original paper, with
-among other things- a more detailed formal study of \CFI. Their formalization
regarded a much simpler machine than the x86 omitting all the complexity in
modern systems. The machine has a few instructions, a separate data memory and
instruction memory which by the operational semantics of the machine are 
non-executable and non-writable (enforcing \NXD and \NWC by construction), and a
small set of registers.
Moreover, their attacker model permits arbitrary changes to the data memory,
arbitrary changes to all the registers but a few distinguished ones that are
used during the dynamic checks and no changes to the instruction memory.
The authors proof that under some assumptions \CFI is preserved for every step
even in the presence of an attacker as powerful as the one described above. 
Their formal study served as a guideline for the implementation, but as it is 
done on paper their proofs cannot be machine checked. Furthermore, their 
formalization omits less interesting but important details such as instruction 
encoding and decoding which as shown in \cite{MorrisettTTTG12} are far from 
trivial for the x86.

Machine-checked formal verification efforts include \cite{ZhaoLSR11}, which is
a SFI formalization for the ARM architecture that also enforces \CFI.
Their formalization was developed using the HOL theorem prover and a program
logic framework they created. However their benchmarks report a 240\% runtime
overhead. The authors of \cite{CriswellDA14} claim partial proofs for a \CFI
enforcement mechanism focused on the kernel of an operating system. Their
runtime overhead can also reach 100\%.

\section{Control-Flow Integrity over PUMP}\label{sec:cfi_pump}

The PUMP hardware allows us to avoid taking the difficult decision between
performance and security. As shown in \cite{pump_ccs2014}, we can enforce a
\emph{fine-grained} \CFI policy with an average overhead of 8\%.
\TODO{Is this number right?}

In our design, we take the standard approach and claim \CFI under \NXD and
\NWC. We considered designs that lifted these assumptions but
we rejected them, for the time being, as there did not seem to be any
considerable advantage \IE{compatibility with self-modifying programs,
JIT compilers, \ETC} Allowing the code of the program to change, would in
practice require for the CFG to change as well, which unless done in
a controlled, ``safe'' way, would invalidate the enforcement of \CFI.
However, we do not have to rely on special hardware or software to enforce
\NXD and \NWC. We can achieve this easily and efficiently by
creating a separate micro-policy.

\subsection{Enforcing Non-Writable Code \& Non-Executable Data}
\label{sec:nwc_nxd}

Consider the set of tags \TAGS{\DATA,\INSTRname}. If we initially tag
all executable regions in memory as \INSTR{} and all non-executable as \DATAname
then we can enforce \NWC by two rules of the form

\begin{figure}[!htpb]
\begin{align*}
 & (Store, \_,\_, \_, \_,\INSTR) \rightarrow \varnothing \\
 & (Store, \_,\_, \_, \_,\DATA) \rightarrow (\_, \DATA)
\end{align*}
\caption{Rules enforcing \NWC}
\end{figure}

The \_ in the vectors, represent \textit{don't care} values. In the context of
the input vector their behavior is the same as \textit{don't care} values in
match expressions in ML languages. In the context of the output vector it just
captures the intuition that we will not really use the result tags, so anything
could be returned as a result tag (\IE \DATAname or we can copy-through tags
from the input vector).
Informally the above rules reads as ``If the current opcode is Store and the
content of the memory location we are trying to write is tagged \INSTR{}
then the memory write is not allowed. Otherwise if it is tagged \DATAname then
the write is permitted and the new value will also be tagged \DATA.''

We can enforce \NXD in a similar fashion
\begin{figure}[!htpb]
\begin{align*}
 & (-, -,\DATA, -, -, -) \rightarrow \varnothing \\
 & (-, -,\INSTR, -, -,-) \rightarrow (-, -)
\end{align*}
\caption{Rules enforcing \NXD}
\end{figure}

Informally the above rules reads as ``If the tag on the current instruction is
\DATAname then execution is not allowed. Otherwise if it is \INSTRname then
execution is allowed''.

\FEEDBACK{Used \_ and -, I think the second one looks better, opinions?}\\
\TODO{Perhaps explain what each tag means for each opcode earlier -- or maybe 
just in appendix?}\\
\FEEDBACK{These tuple-vectors make it hard for people not familiar with them
to remember what each field is, any better ways to represent them?}

\subsection{Enforcing Control-Flow Integrity}\label{sec:cfi_enforce}

\subsubsection{Coarse-grained Control-Flow Integrity}\label{sec:cfi_coarse}
We can use the PUMP to implement the coarse-grained \CFI mechanisms described
earlier. Suppose we want to implement 1-ID \CFI, we tag all indirect flow 
destinations and sources with a tag \MARK and the rest of the instructions as 
\UNMARK. Executing instructions that are sources of indirect flows, propagates
their instruction tag to the \pc. We then have to check that the tag on the
destination matches the tag on the tag on the \pc.

\begin{figure}[!htpb]
\begin{align}
 & (Jump/Jal, -,\MARK, -, -, -) \rightarrow (\MARK,-) \label{coarse_rule1} 
\tag{1} \\
 & (-, \MARK, \MARK, -, -, -) \rightarrow (\UNMARK, -) \label{coarse_rule2}
\tag{2} \\
 & (-, \MARK, \UNMARK, -, -, -) \rightarrow \varnothing \label{coarse_rule3} 
\tag{3}
\end{align}
\caption{Rules enforcing coarse-grained \CFI}
\end{figure}

\TODO{align all elements of the rules above}

Rule \ref{coarse_rule1} is used in the case the opcode is Jump or Jal (the only 
indirect jumps in the RISC machine we examine) and propagates the \MARKname tag on
the tag of the new \pc. Rule \ref{coarse_rule2} applies when the tag on the \pc
is set to \MARKname and corresponds to a legal destination and rule
\ref{coarse_rule3} corresponds to an illegal destination (\IE one that is 
tagged \UNMARK) and is not allowed.

We do not further study this coarse-grained approach as we consider it 
ineffective since attacks against it has already been demonstrated in 
\cite{outofcontrol_ieeesp2014}. Instead we are going to focus on implementing
and formalizing a fine-grained \CFI micro-policy.

\subsubsection{Fine-grained Control-Flow Integrity}\label{sec:cfi_fine}

The micro-policy we implemented and studied is a composition of a fine-grained
\CFI micro-policy and the \NWC, \NXD micro-policies explained above.

Our approach uses unique identifiers to tag the contents of the memory that 
correspond to sources and potential destinations of indirect flows according to
a binary relation (on the identifiers) $\mathcal{CFG}$.

Consider the set of tags 
\TAGS{\DATA,\INSTR{\ii{id}}, \INSTR{\bot}} where \ii{id} is a unique identifier 
(\IE used to tag the contents of only one location in the memory). 
Adapting the rules from \ref{sec:nwc_nxd}, we shall use \DATAname to tag all 
contents in memory that are considered non-executable data, \INSTR{\ii{id}}
to tag all contents in memory that are considered executable instructions and 
are sources or targets of indirect control flows and \INSTR{$\bot$} to tag all
other instructions.
The rules to enforce \NWC and \NXD are intuitively the same and only
change to account for the splitting of the \INSTRname tag.

We follow the same idea as with coarse-grained \CFI, propagating the instruction
tag of instructions that are sources of indirect flows to the tag on the \pc of
the next state and upon execution of the next instruction, checking that the tag
on the \pc and on the instruction are in some relation. In the case of
coarse-grained \CFI we required that they match but for fine-grained \CFI we
require that they are in the \CFG relation.

% \begin{figure}[!htpb]
% \begin{align}
%  & (Jump/Jal, -,-, -, -, -) \rightarrow (- ,-) 
%  \text{ if (n,m) } \in \CFGm \label{fine_rule1} \tag{1} \\
%  & (Jump/Jal, \DATA, \INSTR{m}, -, -, -) \rightarrow (\INSTR{m},-) 
%  \text{ if (n,m) } \in \CFGm \label{fine_rule2} \tag{2} \\
%  & (Store, \DATA, \INSTR{\_}, -, -, \DATA) \rightarrow (\DATA,\DATA) 
%  \label{fine_rule3} \tag{3} \\
%  & (Store, \INSTR{n}, \INSTR{m}, -, -, \DATA) \rightarrow (\DATA,\DATA)
%  \text{ if (n,m) } \in \CFGm \label{fine_rule4} \tag{4} \\
%  & (Store, -, -, -, -, \INSTR{\_}) \rightarrow \varnothing
%   \label{fine_rule5} \tag{5} \\
%  & (-, \INSTR{n}, \INSTR{m}, -, -, -) \rightarrow (\DATA,-)
%  \text{ if (n,m) } \in \CFGm \label{fine_rule6} \tag{6} \\
%  & (-, \DATA, \INSTR{m}, -, -, -) \rightarrow (\DATA,-) \label{fine_rule7} 
%  \tag{7}\\
%  & (-, -, -, -, -, -) \rightarrow \varnothing \label{fine_rule8} 
%  \tag{8}
% \end{align}
% \caption{Rules enforcing fine-grained \CFI, \NXD and \NWC}
% \end{figure}

\begin{figure}[!htpb]
\infrule[Flow/Check]{
  opcode \in \lbrace Jump, Jal \rbrace \andalso 
  (src,dst) \in \CFGm
  }{
  \frule{opcode}{\INSTR{src}}{\INSTR{dst}}{-}{-}{-} {\INSTR{dst}}{-}
  }
\bigskip

\infrule[Flow/NoCheck]{
  opcode \in \lbrace Jump, Jal \rbrace
  }{
  \frule{opcode}{\DATA}{\INSTR{dst}}{-}{-}{-} {\INSTR{dst}}{-}
  }
\bigskip

\infrule[Store/Check]{
  (src,dst) \in \CFGm
  }{
  \frule{Store}{\INSTR{src}}{\INSTR{dst}}{-}{-}{\DATA} {\DATA}{\DATA}
  }
\bigskip

\infrule[Store/NoCheck]{
  ti \in \lbrace \INSTR{dst}, \INSTR{\bot} \rbrace
  }{
  \frule{Store}{\DATA}{ti}{-}{-}{\DATA} {\DATA}{\DATA}
  }
\bigskip

\infrule[Rest/Check]{
  opcode \not \in \lbrace Jump, Jal, Store \rbrace \andalso
  (src,dst) \in \CFGm
  }{
  \frule{opcode}{\INSTR{src}}{\INSTR{dst}}{-}{-}{-} {\DATA}{-}
  }
\bigskip

\infrule[Rest/NoCheck]{
  opcode \not \in \lbrace Jump, Jal, Store \rbrace
  ti \in \lbrace \INSTR{dst}, \INSTR{\bot} \rbrace
  }{
  \frule{opcode}{\DATA}{ti}{-}{-}{-} {\DATA}{-}
  }
\caption{Rules enforcing fine-grained \CFI, \NXD and \NWC}
\end{figure}

We note in the above rules that the tag on the \PCname is \DATAname when
no check for a control-flow violation is required and \INSTR{\textit{src}} where
\textit{src} is some id, when an indirect flow instruction was executed and a
check for a control-flow violation is required. An important observation is that
the rules above allow for one control-flow violation to occur, but disallow the
next step and therefore the machine will certainly halt after a violation.

If the PUMP hardware fetched the tag on the memory address the machine is
jumping to and passed it as an argument to input vector, as it does in the
case of a Store instruction, we would be able to enforce \CFI with no violations
at all. \TODO{It can't do that for efficiency reasons?}






